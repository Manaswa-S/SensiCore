// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: internal.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const getAllSensorData = `-- name: GetAllSensorData :many
SELECT
    sensors_data.value,
    sensors_data.unit,
    sensors_data.id1,
    sensors_data.id2,
    sensors_data.read_at
FROM sensors_data
WHERE 
    (sensors_data.id1 = ? OR ? = 0) AND
    (sensors_data.id2 = ? OR ? = "") AND
    (sensors_data.read_at >= ? OR ? = ?) AND
    (sensors_data.read_at <= ? OR ? = ?)
ORDER BY sensors_data.read_at ASC
LIMIT ?
OFFSET ?
`

type GetAllSensorDataParams struct {
	Id1      int32
	Column2  interface{}
	Id2      string
	Column4  interface{}
	ReadAt   time.Time
	Column6  interface{}
	Column7  interface{}
	ReadAt_2 time.Time
	Column9  interface{}
	Column10 interface{}
	Limit    int32
	Offset   int32
}

type GetAllSensorDataRow struct {
	Value  float64
	Unit   sql.NullString
	Id1    int32
	Id2    string
	ReadAt time.Time
}

func (q *Queries) GetAllSensorData(ctx context.Context, arg GetAllSensorDataParams) ([]GetAllSensorDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSensorData,
		arg.Id1,
		arg.Column2,
		arg.Id2,
		arg.Column4,
		arg.ReadAt,
		arg.Column6,
		arg.Column7,
		arg.ReadAt_2,
		arg.Column9,
		arg.Column10,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSensorDataRow
	for rows.Next() {
		var i GetAllSensorDataRow
		if err := rows.Scan(
			&i.Value,
			&i.Unit,
			&i.Id1,
			&i.Id2,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSensorData = `-- name: InsertSensorData :exec
INSERT INTO sensors_data (value, unit, id1, id2, read_at)
VALUES (?, ?, ?, ?, ?)
`

type InsertSensorDataParams struct {
	Value  float64
	Unit   sql.NullString
	Id1    int32
	Id2    string
	ReadAt time.Time
}

func (q *Queries) InsertSensorData(ctx context.Context, arg InsertSensorDataParams) error {
	_, err := q.db.ExecContext(ctx, insertSensorData,
		arg.Value,
		arg.Unit,
		arg.Id1,
		arg.Id2,
		arg.ReadAt,
	)
	return err
}
